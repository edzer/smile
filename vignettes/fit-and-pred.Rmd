---
title: "2. Fitting models and making predictions"
output: rmarkdown::html_vignette
bibliography: biblio.bib
vignette: >
  %\VignetteIndexEntry{2. Fitting models and making predictions}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(smile)
library(ggplot2)
library(sf)
```

---

If interested in the theory involving this calculations, take a look at [this
vignette](https://lcgodoy.me/smile/articles/theory.html).

---

Considering the same setup used in the vignette about converting `sf` to `spm`
[objects](https://lcgodoy.me/smile/articles/sf-to-spm.html), we are going to
predict the Life Expecation at Birth (LEF) score (observed at the Middle Super
Output Areas (MSOA), in Liverpool, into the Lower Super Output Area (LSOA). In
this second level, we have the Life Expectancy at Birth for each area.

The code below loads the data and converts the LSOA `sf` object into a `spm`
object. In particular, we are going to use numerical integration (based on a 1000
points grid) with the precision of the integrals varying according to the size
of each MSOA region. The name of the variable we are interested in, in the
`liv_msoa`, is `"leb_est"`.
```{R load-data}
data(liv_msoa)
data(liv_lsoa)

## workaround for compatibility with different PROJ versions
st_crs(liv_msoa) <-
    st_crs(liv_msoa)$input

st_crs(liv_lsoa) <-
    st_crs(liv_lsoa)$input

## msoa from sf to spm
spm_msoa <-
    sf_to_spm(sf_obj = liv_msoa,
              n_pts  = 1000,
              type   = "regular",
              by_polygon = FALSE,
              poly_ids = "msoa11cd",
              var_ids  = "leb_est")
```

Next, we assume the following model, at the grid level, drives the data^[To
check how the model at the grid level relates to the data at the area level
check the [Theory vignette](https://lcgodoy.me/smile/articles/theory.html)] \[
Y(\mathbf{s}) = \mu + S(\mathbf{s}) + \varepsilon(\mathbf{s}), \] where
$S(\cdot) \sim {\rm GP}(0, {\rm C}(\cdot ; \, \boldsymbol{\theta}))$, and
$\varepsilon(\cdot) \overset{{\rm i.i.d.}}{\sim} {\rm N}(0, \tau)$, with
$S(\cdot) \pert \varepsilon(\cdot)$. The (auto) covariance function ${\rm
C}(\cdot ; \, \boldsymbol{\theta} ) = \sigma^2 \rho(\cdot ; \,
\boldsymbol{\theta})$. Where $\rho(\cdot ; \, \boldsymbol{\theta})$ is a
stationary and isotropic covariance function. To check the families of functions
available on the package, check [this
link](https://lcgodoy.me/smile/articles/sp-cov-functions.html). Another
important detail is that if we make $\nu = \tau / \sigma^2$, the estimation
process is slightly easier. The package allows for the two parametrizations.

For this problem we are going to consider the the Mat\'{e}rn correlation
function. The model will be fitted with $\kappa = .5, 1.5, 2.5$, this the
parameter that control the smoothness of the spatial process. Also, we use the
parametrization with $\nu$ instead of $\tau$. Next, we evaluate the AIC
associated with three models. The function `fit_spm` is used to fit the
models. This function needs starting values for $\phi$ and $\nu$, the covariance
model to be used (in this case, `"matern"`). Note that, we are not inputting an
initial value for $\nu$. When not inputting an initial value for $\nu$, we are
forcing this parameter to be 0. This is done because there are identifiability
issues associated with such parameter. The commented part of the code below
shows how to proceed to estimate this parameter from the data. The argument
`apply_exp` is a workaround for searching $\phi$ and $\nu = \tau / \sigma^2$
over the whole real line. The arguments `opt_method` and `control` are passed to
the function `optim` in order to optimize the log likelihood associated with the
data.
```{R fit-pred-1}
theta_st_msoa <- c("phi" = 1)

## 1) it is important to NAME the initial values for each parameter
## 2) to estimate "nu" from the data we only need to provide an initial value for such
## parameter
## 3) uncomment the code below to do so.
## 4) Note that it is possible to set the boundaries for the parameter space on
## which we want to optmize the likelihood.
## theta_st_msoa <- c("phi" = 1, "nu" = 1)
## fit_msoa1 <-
##     fit_spm(x = spm_msoa,
##             theta_st = theta_st_msoa,
##             model = "matern",
##             kappa = .5,
##             lower = c(1e-16, 1e-16),
##             upper = c(Inf, 1),
##             opt_method = "L-BFGS-B",
##             control   = list(maxit = 500))

fit_msoa1 <-
    fit_spm(x = spm_msoa,
            theta_st = theta_st_msoa,
            model = "matern",
            kappa = .5,
            apply_exp = TRUE,
            opt_method = "L-BFGS-B",
            control   = list(maxit = 500))

fit_msoa2 <-
    fit_spm(x = spm_msoa,
            theta_st = theta_st_msoa,
            model = "matern",
            kappa = 1.5,
            apply_exp = TRUE,
            opt_method = "L-BFGS-B",
            control   = list(maxit = 500))

fit_msoa3 <-
    fit_spm(x = spm_msoa,
            theta_st = theta_st_msoa,
            model = "matern",
            kappa = 2.5,
            apply_exp = TRUE,
            opt_method = "L-BFGS-B",
            control   = list(maxit = 500))
```

The AIC^[The BIC works for our models too.] associated with each model is given
below. According to this criterion, the best model is the one with $\kappa =
.5$.
```{r AIC, echo = TRUE, eval = TRUE}
c("m1" = AIC(fit_msoa1), "m2" = AIC(fit_msoa2), "m3" = AIC(fit_msoa3))
```

We can retrieve the estimated parameters and the associated `(1 - sig)` %
confidence intervals by using the function `summary_spm_fit` as follows
```{R summary-fit1}
summary_spm_fit(fit_msoa1, sig = .05)
```

Finally, we have almost everything we need to perform predictions at the LSOA
areas. The function `predict_spm` calculates the predictions associated to the
`spm_obj` (which contains the results associated with a fitted model) into a
`sf` object `x`. We need to specify whether we want to "aggregate"
(i.e. average) the predicted surface into the polygons associated with the `sf`
data. The number of points and the type of integration for prediction need to be
set as well. In this case we are specifying a finer grid because the LSOA areas
are smaller than the MSOA areas.
```{R predict-fit1}
pred_lsoa <- predict_spm(x = liv_lsoa, spm_obj = fit_msoa1,
                         .aggregate = TRUE, n_pts = 3500,
                         type = "regular")
```

The resulting object is a list with entries `"mu_pred"`, `"sig_pred"`,
`"pred_grid"`, `"pred_agg"`. The first two positions correspond to the mean and
covariance matrix at the predicted locations, respectively. `"pred_grid"` can be
seen as the predicted surface over the study region, while `"pred_agg"` contains
the (integrals) averages of such surface within each LSOA area. The chunk of
code below plots the predicted surface.
```{R manip-pred-1}
aux_viz1 <- vector(mode   = "list",
                   length = 4)

aux_viz1[[1]] <- transform(pred_lsoa$pred_grid["mu_pred"],
                           surface  = "continuous",
                           variable = "prediction")
names(aux_viz1[[1]])[1] <- "value"
aux_viz1[[2]] <- transform(pred_lsoa$pred_grid["se_pred"],
                           surface  = "continuous",
                           variable = "se")
names(aux_viz1[[2]])[1] <- "value"
aux_viz1[[3]] <- transform(pred_lsoa$pred_agg["mu_pred"],
                           surface  = "aggregated",
                           variable = "prediction")
names(aux_viz1[[3]])[1] <- "value"
aux_viz1[[4]] <- transform(pred_lsoa$pred_agg["se_pred"],
                           surface  = "aggregated",
                           variable = "se")
names(aux_viz1[[4]])[1] <- "value"

aux_viz1 <- do.call("rbind", aux_viz1)

ggplot(data = aux_viz1[aux_viz1$variable == "prediction",],
       aes(fill  = value,
           color = value)) +
    geom_sf(data = st_geometry(pred_lsoa$pred_agg), color = 1,
            lwd = .1, inherit.aes = FALSE) +
    geom_sf(pch = 15) +
    scale_fill_viridis_c(option = "H") +
    scale_color_viridis_c(option = "H") +
    guides(color = "none",
           fill = "none") +
    facet_wrap(surface ~ .) +
    theme_bw() +
    theme(axis.text = element_blank())
```

Next, we plot the standard errors associated with the predictions.
```{R se-ggplot2}
ggplot(data = aux_viz1[aux_viz1$variable == "se",],
       aes(fill  = value,
           color = value)) +
    geom_sf(data = st_geometry(pred_lsoa$pred_agg), color = 1,
            lwd = .1, inherit.aes = FALSE) +
    geom_sf(pch = 15) +
    scale_fill_viridis_c(option = "H") +
    scale_color_viridis_c(option = "H") +
    guides(color = "none",
           fill = "none") +
    facet_wrap(surface ~ .) +
    theme_bw() +
    theme(axis.text = element_blank())
```

```{R rm-obj1, echo = FALSE}
rm(aux_viz1, pred_lsoa, fit_msoa)
invisible(gc(full = TRUE))
```

Lastly, the next chunk of code plots the observed and predicted LEB at the MSOAs
and LSOAs, respectively.

# Reference
